<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGP Protocol Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #333;
        }
        main {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin: 1rem;
            max-width: 900px;
            width: calc(100% - 2rem);
            text-align: center;
        }
        h1 {
            color: #1a202c;
            font-size: 2.25rem;
            margin-bottom: 0.5rem;
        }
        p {
            color: #4a5568;
            margin-bottom: 1.5rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #canvas-container {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            margin-bottom: 1.5rem;
            width: 100%;
            height: 0;
            padding-bottom: 60%; /* Aspect ratio */
            position: relative;
        }
        #canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #reset-button {
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            margin: 1.5rem 0 0 0;
        }
        #reset-button:hover {
            background-color: #3182ce;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

    <main>
        <h1>BGP Protocol Visualization</h1>
        <p>This animation demonstrates how routing information propagates through a network of Autonomous Systems (AS). When an AS advertises a network prefix, it creates a route and attaches its own number to an attribute called the AS_PATH. As this advertisement is passed to the next AS, that AS prepends its own number to the list. This creates an ordered sequence of AS numbers, the "AS Path," which functions as a distance vector, showing the exact path the advertisement has traveled.<br><br>When an AS receives multiple advertisements for the same prefix, it compares the AS_PATH lists. The path with the fewest AS numbers in its list is considered the shortest and is selected as the best route to the destination.</p>
        <div id="canvas-container"></div>
        <button id="reset-button">Reset Simulation</button>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e2e8f0;"></div>
                <span>Idle AS</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #63b3ed;"></div>
                <span>Advertising AS</span>
            </div>
             <div class="legend-item">
                <div class="legend-color" style="background-color: #c6f6d5;"></div>
                <span>AS with Path</span>
            </div>
        </div>
    </main>

    <script>
        // --- P5.js Sketch ---

        let systems = [];
        let advertisements = [];
        let nextPrefix = 1;
        let canvas;

        // --- Autonomous System (AS) Class ---
        class AutonomousSystem {
            constructor(asn, x, y) {
                this.asn = asn;
                this.pos = createVector(x, y);
                this.size = 60;
                this.neighbors = [];
                // Routing Information Base (RIB)
                // { prefix: { allPaths: [{path, fromNeighbor}], bestPath: path } }
                this.rib = {};
                this.color = color(226, 232, 240); // neutral color
                this.targetColor = this.color;
                this.hoverTargets = []; // For tooltips
            }

            addNeighbor(neighbor) {
                this.neighbors.push(neighbor);
            }

            // Originate a new prefix
            advertise() {
                const prefix = `10.0.${nextPrefix}.0/24`;
                nextPrefix++;
                const newPath = [this.asn];
                this.receiveAdvertisement({ prefix, path: newPath }, null); // Receive its own ad
                this.targetColor = color(99, 179, 237); // advertising color
            }

            // Receive an advertisement from a neighbor
            receiveAdvertisement(ad, fromNeighbor) {
                const { prefix, path } = ad;

                // BGP loop prevention: Only check if the ad is from a neighbor
                if (fromNeighbor && path.includes(this.asn)) {
                    return;
                }

                // Initialize RIB entry if it doesn't exist
                if (!this.rib[prefix]) {
                    this.rib[prefix] = {
                        allPaths: [],
                        bestPath: null
                    };
                }

                const ribEntry = this.rib[prefix];

                // Add the new path to the list of all paths
                ribEntry.allPaths.push({ path: path, fromNeighbor: fromNeighbor });

                // Determine the new best path
                let currentBest = ribEntry.bestPath;
                let newBest = currentBest;

                if (!currentBest || path.length < currentBest.length) {
                    newBest = path;
                }

                // If the best path changed, update and propagate
                if (JSON.stringify(newBest) !== JSON.stringify(currentBest)) {
                    ribEntry.bestPath = newBest;
                    // Propagate the new best path to neighbors
                    this.propagate(prefix, newBest);
                }
                
                if (Object.keys(this.rib).length > 0 && this.targetColor.toString() !== color(99, 179, 237).toString()) {
                    this.targetColor = color(198, 246, 213); // Has path color
                }
            }

            // Propagate a route to all neighbors
            propagate(prefix, path) {
                for (let neighbor of this.neighbors) {
                    const newPath = [this.asn, ...path];
                    const newAd = new Advertisement(
                        this.pos.copy(),
                        neighbor.pos.copy(),
                        { prefix: prefix, path: newPath },
                        neighbor
                    );
                    advertisements.push(newAd);
                }
            }

            display() {
                // Smooth color transition
                this.color = lerpColor(this.color, this.targetColor, 0.1);
                this.hoverTargets = []; // Reset hover targets each frame

                stroke(50);
                strokeWeight(2);
                fill(this.color);
                ellipse(this.pos.x, this.pos.y, this.size, this.size);

                // Display ASN
                noStroke();
                fill(0);
                textAlign(CENTER, CENTER);
                textSize(14);
                textStyle(BOLD);
                text(`AS ${this.asn}`, this.pos.x, this.pos.y);

                // Display RIB
                textSize(10);
                textAlign(CENTER, TOP);
                let yOffset = this.pos.y + this.size / 2 + 10;
                
                const MAX_PREFIXES_TO_SHOW = 2;
                const prefixes = Object.keys(this.rib);

                for (let i = 0; i < Math.min(prefixes.length, MAX_PREFIXES_TO_SHOW); i++) {
                    const prefix = prefixes[i];
                    const ribEntry = this.rib[prefix];
                    fill(0);
                    textStyle(BOLD);
                    text(prefix, this.pos.x, yOffset);
                    yOffset += 12;
                    textStyle(NORMAL);

                    const sortedPaths = [...ribEntry.allPaths].sort((a, b) => a.path.length - b.path.length);

                    const MAX_PATHS_TO_SHOW = 3;
                    let pathsShown = 0;
                    for (const p of sortedPaths) {
                        if (pathsShown >= MAX_PATHS_TO_SHOW) break;
                        const isBest = JSON.stringify(p.path) === JSON.stringify(ribEntry.bestPath);
                        if (isBest) {
                            fill(0, 100, 0); // Dark Green
                            textStyle(BOLD);
                            text(`> ${p.path.join(' â†’ ')}`, this.pos.x, yOffset);
                            textStyle(NORMAL);
                            yOffset += 12;
                            pathsShown++;
                        }
                    }
                    for (const p of sortedPaths) {
                        if (pathsShown >= MAX_PATHS_TO_SHOW) break;
                         const isBest = JSON.stringify(p.path) === JSON.stringify(ribEntry.bestPath);
                         if(!isBest) {
                             fill(120); // Grey
                             text(`  ${p.path.join(' â†’ ')}`, this.pos.x, yOffset);
                             yOffset += 12;
                             pathsShown++;
                         }
                    }

                    if (sortedPaths.length > MAX_PATHS_TO_SHOW) {
                        fill(150);
                        const indicatorText = '  (...)';
                        text(indicatorText, this.pos.x, yOffset);
                        
                        const indicatorWidth = textWidth(indicatorText);
                        const indicatorHeight = 12;
                        this.hoverTargets.push({
                            type: 'paths',
                            prefix: prefix,
                            x: this.pos.x - indicatorWidth / 2,
                            y: yOffset - indicatorHeight/2,
                            w: indicatorWidth,
                            h: indicatorHeight,
                        });
                        yOffset += 12;
                    }

                    yOffset += 5; // Spacer between prefixes
                }

                if (prefixes.length > MAX_PREFIXES_TO_SHOW) {
                     fill(150);
                     const indicatorText = '(...)';
                     text(indicatorText, this.pos.x, yOffset);
                     const indicatorWidth = textWidth(indicatorText);
                     const indicatorHeight = 12;
                     this.hoverTargets.push({
                         type: 'rib',
                         x: this.pos.x - indicatorWidth / 2,
                         y: yOffset - indicatorHeight / 2,
                         w: indicatorWidth,
                         h: indicatorHeight
                     });
                }
            }
        }

        // --- Advertisement Packet Class ---
        class Advertisement {
            constructor(start, end, data, target) {
                this.start = start;
                this.end = end;
                this.data = data;
                this.target = target;
                this.progress = 0;
            }

            update() {
                this.progress += 0.02;
                if (this.progress >= 1) {
                    this.target.receiveAdvertisement(this.data, this.start);
                    return true; // Mark for removal
                }
                return false;
            }

            display() {
                const currentPos = p5.Vector.lerp(this.start, this.end, this.progress);
                fill(255, 165, 0, 200); // Orange
                noStroke();
                ellipse(currentPos.x, currentPos.y, 15, 15);
                
                // Display info on hover
                if (dist(mouseX, mouseY, currentPos.x, currentPos.y) < 15) {
                     push();
                     fill(255, 255, 240, 240);
                     stroke(100);
                     rectMode(CORNER);
                     let pathStr = `${this.data.prefix}: ${this.data.path.join('â†’')}`;
                     let boxWidth = textWidth(pathStr) + 10;
                     rect(currentPos.x + 10, currentPos.y - 10, boxWidth, 20, 3);
                     fill(0);
                     noStroke();
                     textAlign(LEFT, CENTER);
                     text(pathStr, currentPos.x + 15, currentPos.y);
                     pop();
                }
            }
        }

        // --- P5.js Setup ---
        function setup() {
            let container = document.getElementById('canvas-container');
            let w = container.offsetWidth;
            let h = w * 0.6; // Maintain aspect ratio
            canvas = createCanvas(w, h);
            canvas.parent('canvas-container');

            document.getElementById('reset-button').addEventListener('click', resetSimulation);
            
            resetSimulation();
        }
        
        // --- P5.js Draw Loop ---
        function draw() {
            background(255);

            // Draw connections between systems
            stroke(180);
            strokeWeight(3);
            for (let as1 of systems) {
                for (let as2 of as1.neighbors) {
                    // To avoid drawing lines twice, only draw if as1's number is smaller
                    if (as1.asn < as2.asn) {
                        line(as1.pos.x, as1.pos.y, as2.pos.x, as2.pos.y);
                    }
                }
            }

            // Update and display advertisements
            for (let i = advertisements.length - 1; i >= 0; i--) {
                advertisements[i].display();
                if (advertisements[i].update()) {
                    advertisements.splice(i, 1);
                }
            }

            // Display systems
            for (let as of systems) {
                as.display();
            }

            // --- Tooltip Logic ---
            let activeTooltip = null;
            for (const as of systems) {
                for (const target of as.hoverTargets) {
                    if (mouseX > target.x && mouseX < target.x + target.w && mouseY > target.y && mouseY < target.y + target.h) {
                        activeTooltip = { as, target };
                        break;
                    }
                }
                if (activeTooltip) break;
            }

            if (activeTooltip) {
                drawTooltip(activeTooltip.as, activeTooltip.target);
            }
        }
        
        // --- Interactivity ---
        function mousePressed() {
            if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;
            for (let as of systems) {
                if (dist(mouseX, mouseY, as.pos.x, as.pos.y) < as.size / 2) {
                    as.advertise();
                }
            }
        }
        
        // --- Tooltip Drawing Function ---
        function drawTooltip(as, target) {
            push(); // Isolate tooltip styles
            if (target.type === 'paths') {
                const prefix = target.prefix;
                const ribEntry = as.rib[prefix];
                if (!ribEntry) return;

                const allPaths = [...ribEntry.allPaths].sort((a, b) => a.path.length - b.path.length);
                const bestPath = ribEntry.bestPath;

                const padding = 8;
                const lineHeight = 12;
                const titleHeight = 15;
                let maxWidth = textWidth(`All Paths for ${prefix}`) + 2 * padding;

                for (const p of allPaths) {
                    const pathText = `> ${p.path.join(' â†’ ')}`;
                    maxWidth = max(maxWidth, textWidth(pathText) + 2 * padding);
                }

                const boxHeight = titleHeight + (allPaths.length * lineHeight) + 2 * padding;
                const boxWidth = maxWidth;

                let boxX = mouseX + 15;
                let boxY = mouseY + 15;
                if (boxX + boxWidth > width) boxX = mouseX - boxWidth - 15;
                if (boxY + boxHeight > height) boxY = mouseY - boxHeight - 15;

                rectMode(CORNER);
                fill(255, 255, 240, 240);
                stroke(100);
                strokeWeight(1);
                rect(boxX, boxY, boxWidth, boxHeight, 5);

                noStroke();
                fill(0);
                textAlign(LEFT, TOP);
                textStyle(BOLD);
                textSize(11);
                text(`All Paths for ${prefix}`, boxX + padding, boxY + padding);
                
                textStyle(NORMAL);
                textSize(10);
                let yOffset = boxY + padding + titleHeight;
                for (const p of allPaths) {
                    const isBest = JSON.stringify(p.path) === JSON.stringify(bestPath);
                    if (isBest) {
                        fill(0, 100, 0);
                        textStyle(BOLD);
                    } else {
                        fill(80);
                        textStyle(NORMAL);
                    }
                    text(`${p.path.join(' â†’ ')}`, boxX + padding, yOffset);
                    yOffset += lineHeight;
                }
            } else if (target.type === 'rib') {
                const allPrefixes = Object.keys(as.rib);
                const padding = 8;
                const lineHeight = 12;
                const titleHeight = 15;
                let maxWidth = textWidth(`Full RIB for AS ${as.asn}`) + 2 * padding;

                for (const prefix of allPrefixes) {
                    const bestPath = as.rib[prefix].bestPath;
                    if (bestPath) {
                        const pathText = `${prefix}: ${bestPath.join(' â†’ ')}`;
                        maxWidth = max(maxWidth, textWidth(pathText) + 2 * padding);
                    }
                }

                const boxHeight = titleHeight + (allPrefixes.length * lineHeight) + 2 * padding;
                const boxWidth = maxWidth;
                
                let boxX = mouseX + 15;
                let boxY = mouseY + 15;
                if (boxX + boxWidth > width) boxX = mouseX - boxWidth - 15;
                if (boxY + boxHeight > height) boxY = mouseY - boxHeight - 15;

                rectMode(CORNER);
                fill(255, 255, 240, 240);
                stroke(100);
                strokeWeight(1);
                rect(boxX, boxY, boxWidth, boxHeight, 5);

                noStroke();
                fill(0);
                textAlign(LEFT, TOP);
                textStyle(BOLD);
                textSize(11);
                text(`Full RIB for AS ${as.asn}`, boxX + padding, boxY + padding);

                textStyle(NORMAL);
                textSize(10);
                let yOffset = boxY + padding + titleHeight;
                for (const prefix of allPrefixes) {
                    const bestPath = as.rib[prefix].bestPath;
                    if (bestPath) {
                        fill(0,100,0);
                        text(`${prefix}: `, boxX+padding, yOffset);
                        const prefixWidth = textWidth(`${prefix}: `);
                        fill(80);
                        text(`${bestPath.join(' â†’ ')}`, boxX + padding + prefixWidth, yOffset);
                        yOffset += lineHeight;
                    }
                }
            }
            pop(); // Restore original styles
        }
        
        function windowResized() {
            let container = document.getElementById('canvas-container');
            // Recalculate canvas size on resize
            let w = container.offsetWidth;
            let h = w * 0.6;
            resizeCanvas(w, h);
            // Recalculate node positions
            createTopology();
        }

        function resetSimulation() {
             advertisements = [];
             nextPrefix = 1;
             createTopology();
        }

        // --- Topology Creation ---
        function createTopology() {
            systems = []; // Clear any existing systems

            // Create Autonomous Systems, positions are relative to canvas size
            const as1 = new AutonomousSystem(100, width * 0.2, height * 0.25);
            const as2 = new AutonomousSystem(200, width * 0.5, height * 0.15);
            const as3 = new AutonomousSystem(300, width * 0.8, height * 0.25);
            const as4 = new AutonomousSystem(400, width * 0.35, height * 0.75);
            const as5 = new AutonomousSystem(500, width * 0.65, height * 0.75);

            // Establish peering (connections)
            as1.addNeighbor(as2);
            as2.addNeighbor(as1);

            as2.addNeighbor(as3);
            as3.addNeighbor(as2);

            as1.addNeighbor(as4);
            as4.addNeighbor(as1);
            
            as3.addNeighbor(as5);
            as5.addNeighbor(as3);

            as4.addNeighbor(as5);
            as5.addNeighbor(as4);
            
            as2.addNeighbor(as5);
            as5.addNeighbor(as2);

            systems.push(as1, as2, as3, as4, as5);
        }
    </script>
</body>
</html>

